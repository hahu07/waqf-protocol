use crate::waqf_types::{WaqfData};
use serde::{Deserialize, Serialize};
use std::fmt;

// Production-grade validation constants
const MIN_TITLE_LENGTH: usize = 3;
const MAX_TITLE_LENGTH: usize = 100;
const MIN_DESCRIPTION_LENGTH: usize = 10;
const MAX_DESCRIPTION_LENGTH: usize = 2000;
const MIN_BENEFICIARY_LENGTH: usize = 2;
const MAX_BENEFICIARY_LENGTH: usize = 200;
const MIN_ENDOWMENT_AMOUNT: f64 = 0.01; // Minimum viable endowment
const MAX_ENDOWMENT_AMOUNT: f64 = 1_000_000_000.0; // 1 billion cap

// Define valid status transitions for business logic
const VALID_STATUSES: &[&str] = &["draft", "pending_approval", "active", "paused", "completed", "cancelled", "expired"];

// Status transition matrix - defines what transitions are allowed
const VALID_TRANSITIONS: &[(&str, &[&str])] = &[
    ("draft", &["pending_approval", "cancelled"]),
    ("pending_approval", &["active", "draft", "cancelled"]),
    ("active", &["paused", "completed", "expired"]),
    ("paused", &["active", "cancelled", "expired"]),
    ("completed", &[]), // Terminal state
    ("cancelled", &[]), // Terminal state
    ("expired", &[]), // Terminal state
];

/// Comprehensive validation error types for better error handling
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
pub enum WaqfValidationError {
    /// Title validation errors
    TitleTooShort { min_length: usize, actual: usize },
    TitleTooLong { max_length: usize, actual: usize },
    TitleEmpty,
    TitleContainsInvalidCharacters(String),
    
    /// Description validation errors
    DescriptionTooShort { min_length: usize, actual: usize },
    DescriptionTooLong { max_length: usize, actual: usize },
    DescriptionEmpty,
    DescriptionContainsInvalidCharacters(String),
    
    /// Beneficiary validation errors
    BeneficiaryTooShort { min_length: usize, actual: usize },
    BeneficiaryTooLong { max_length: usize, actual: usize },
    BeneficiaryEmpty,
    BeneficiaryInvalidFormat(String),
    
    /// Financial validation errors
    EndowmentAmountTooLow { min_amount: f64, actual: f64 },
    EndowmentAmountTooHigh { max_amount: f64, actual: f64 },
    EndowmentAmountInvalid(String),
    
    /// Status validation errors
    InvalidStatus { status: String, valid_statuses: Vec<String> },
    InvalidStatusTransition { from: String, to: String },
    
    /// Temporal validation errors
    CreatedAtInvalid(String),
    UpdatedAtInvalid(String),
    TimestampInFuture { timestamp: u64, current: u64 },
    UpdatedBeforeCreated { created_at: u64, updated_at: u64 },
    
    /// Creator validation errors
    CreatedByEmpty,
    CreatedByInvalidFormat(String),
    
    /// Business logic errors
    InactiveWaqfModification,
    CompletedWaqfModification,
    DuplicateWaqf(String),
}

impl fmt::Display for WaqfValidationError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::TitleTooShort { min_length, actual } => {
                write!(f, "Title too short: minimum {} characters, got {}", min_length, actual)
            }
            Self::TitleTooLong { max_length, actual } => {
                write!(f, "Title too long: maximum {} characters, got {}", max_length, actual)
            }
            Self::TitleEmpty => write!(f, "Title cannot be empty"),
            Self::TitleContainsInvalidCharacters(chars) => {
                write!(f, "Title contains invalid characters: {}", chars)
            }
            
            Self::DescriptionTooShort { min_length, actual } => {
                write!(f, "Description too short: minimum {} characters, got {}", min_length, actual)
            }
            Self::DescriptionTooLong { max_length, actual } => {
                write!(f, "Description too long: maximum {} characters, got {}", max_length, actual)
            }
            Self::DescriptionEmpty => write!(f, "Description cannot be empty"),
            Self::DescriptionContainsInvalidCharacters(chars) => {
                write!(f, "Description contains invalid characters: {}", chars)
            }
            
            Self::BeneficiaryTooShort { min_length, actual } => {
                write!(f, "Beneficiary name too short: minimum {} characters, got {}", min_length, actual)
            }
            Self::BeneficiaryTooLong { max_length, actual } => {
                write!(f, "Beneficiary name too long: maximum {} characters, got {}", max_length, actual)
            }
            Self::BeneficiaryEmpty => write!(f, "Beneficiary cannot be empty"),
            Self::BeneficiaryInvalidFormat(reason) => {
                write!(f, "Invalid beneficiary format: {}", reason)
            }
            
            Self::EndowmentAmountTooLow { min_amount, actual } => {
                write!(f, "Endowment amount too low: minimum {}, got {}", min_amount, actual)
            }
            Self::EndowmentAmountTooHigh { max_amount, actual } => {
                write!(f, "Endowment amount too high: maximum {}, got {}", max_amount, actual)
            }
            Self::EndowmentAmountInvalid(reason) => {
                write!(f, "Invalid endowment amount: {}", reason)
            }
            
            Self::InvalidStatus { status, valid_statuses } => {
                write!(f, "Invalid status '{}'. Valid statuses: {}", status, valid_statuses.join(", "))
            }
            Self::InvalidStatusTransition { from, to } => {
                write!(f, "Invalid status transition from '{}' to '{}'", from, to)
            }
            
            Self::CreatedAtInvalid(reason) => write!(f, "Invalid created_at timestamp: {}", reason),
            Self::UpdatedAtInvalid(reason) => write!(f, "Invalid updated_at timestamp: {}", reason),
            Self::TimestampInFuture { timestamp, current } => {
                write!(f, "Timestamp {} is in the future (current: {})", timestamp, current)
            }
            Self::UpdatedBeforeCreated { created_at, updated_at } => {
                write!(f, "Updated timestamp ({}) is before created timestamp ({})", updated_at, created_at)
            }
            
            Self::CreatedByEmpty => write!(f, "Created by field cannot be empty"),
            Self::CreatedByInvalidFormat(reason) => write!(f, "Invalid creator format: {}", reason),
            
            Self::InactiveWaqfModification => {
                write!(f, "Cannot modify inactive waqf - change status first")
            }
            Self::CompletedWaqfModification => {
                write!(f, "Cannot modify completed waqf")
            }
            Self::DuplicateWaqf(title) => write!(f, "Waqf with title '{}' already exists", title),
        }
    }
}

/// Validation result with detailed error information
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct WaqfValidationResult {
    pub is_valid: bool,
    pub errors: Vec<WaqfValidationError>,
    pub warnings: Vec<String>,
}

impl WaqfValidationResult {
    pub fn new() -> Self {
        Self {
            is_valid: true,
            errors: Vec::new(),
            warnings: Vec::new(),
        }
    }
    
    pub fn add_error(&mut self, error: WaqfValidationError) {
        self.is_valid = false;
        self.errors.push(error);
    }
    
    pub fn add_warning(&mut self, warning: String) {
        self.warnings.push(warning);
    }
    
    pub fn merge(&mut self, other: WaqfValidationResult) {
        if !other.is_valid {
            self.is_valid = false;
        }
        self.errors.extend(other.errors);
        self.warnings.extend(other.warnings);
    }
}

/// Comprehensive waqf data validation with detailed error reporting
pub fn validate_waqf_data(data: &WaqfData) -> std::result::Result<(), String> {
    let validation_result = validate_waqf_data_detailed(data, None);
    
    if validation_result.is_valid {
        Ok(())
    } else {
        let error_messages: Vec<String> = validation_result.errors
            .iter()
            .map(|e| e.to_string())
            .collect();
        Err(error_messages.join("; "))
    }
}

/// Detailed validation with comprehensive error reporting
pub fn validate_waqf_data_detailed(
    data: &WaqfData, 
    current_data: Option<&WaqfData>
) -> WaqfValidationResult {
    let mut result = WaqfValidationResult::new();
    
    // Validate title
    validate_title(&data.title, &mut result);
    
    // Validate description
    validate_description(&data.description, &mut result);
    
    // Validate beneficiary
    validate_beneficiary(&data.beneficiary, &mut result);
    
    // Validate endowment amount
    validate_endowment_amount(data.endowment_amount, &mut result);
    
    // Validate status
    validate_status(&data.status, &mut result);
    
    // Validate status transition if updating existing waqf
    if let Some(current) = current_data {
        validate_status_transition(&current.status, &data.status, &mut result);
        validate_update_permissions(current, data, &mut result);
    }
    
    // Validate timestamps
    validate_timestamps(data.created_at, data.updated_at, &mut result);
    
    // Validate creator
    validate_creator(&data.created_by, &mut result);
    
    // Business logic validations
    validate_business_rules(data, current_data, &mut result);
    
    result
}

/// Validate title field
fn validate_title(title: &str, result: &mut WaqfValidationResult) {
    let trimmed = title.trim();
    
    if trimmed.is_empty() {
        result.add_error(WaqfValidationError::TitleEmpty);
        return;
    }
    
    if trimmed.len() < MIN_TITLE_LENGTH {
        result.add_error(WaqfValidationError::TitleTooShort {
            min_length: MIN_TITLE_LENGTH,
            actual: trimmed.len(),
        });
    }
    
    if trimmed.len() > MAX_TITLE_LENGTH {
        result.add_error(WaqfValidationError::TitleTooLong {
            max_length: MAX_TITLE_LENGTH,
            actual: trimmed.len(),
        });
    }
    
    // Check for invalid characters (allow letters, numbers, spaces, and basic punctuation)
    let invalid_chars: Vec<char> = trimmed.chars()
        .filter(|&c| !is_valid_text_character(c))
        .collect();
    
    if !invalid_chars.is_empty() {
        let invalid_str: String = invalid_chars.into_iter().collect();
        result.add_error(WaqfValidationError::TitleContainsInvalidCharacters(invalid_str));
    }
    
    // Warning for potentially problematic titles
    if trimmed.chars().all(|c| c.is_uppercase()) {
        result.add_warning("Title is all uppercase - consider using proper case".to_string());
    }
}

/// Validate description field
fn validate_description(description: &str, result: &mut WaqfValidationResult) {
    let trimmed = description.trim();
    
    if trimmed.is_empty() {
        result.add_error(WaqfValidationError::DescriptionEmpty);
        return;
    }
    
    if trimmed.len() < MIN_DESCRIPTION_LENGTH {
        result.add_error(WaqfValidationError::DescriptionTooShort {
            min_length: MIN_DESCRIPTION_LENGTH,
            actual: trimmed.len(),
        });
    }
    
    if trimmed.len() > MAX_DESCRIPTION_LENGTH {
        result.add_error(WaqfValidationError::DescriptionTooLong {
            max_length: MAX_DESCRIPTION_LENGTH,
            actual: trimmed.len(),
        });
    }
    
    // Check for invalid characters (simpler check for descriptions)
    // Just allow all non-control characters for more flexibility
    let invalid_chars: Vec<char> = trimmed.chars()
        .filter(|&c| !c.is_alphanumeric() && c.is_control())
        .collect();
    
    if !invalid_chars.is_empty() {
        let invalid_str: String = invalid_chars.into_iter().collect();
        result.add_error(WaqfValidationError::DescriptionContainsInvalidCharacters(invalid_str));
    }
}

/// Validate beneficiary field
fn validate_beneficiary(beneficiary: &str, result: &mut WaqfValidationResult) {
    let trimmed = beneficiary.trim();
    
    if trimmed.is_empty() {
        result.add_error(WaqfValidationError::BeneficiaryEmpty);
        return;
    }
    
    if trimmed.len() < MIN_BENEFICIARY_LENGTH {
        result.add_error(WaqfValidationError::BeneficiaryTooShort {
            min_length: MIN_BENEFICIARY_LENGTH,
            actual: trimmed.len(),
        });
    }
    
    if trimmed.len() > MAX_BENEFICIARY_LENGTH {
        result.add_error(WaqfValidationError::BeneficiaryTooLong {
            max_length: MAX_BENEFICIARY_LENGTH,
            actual: trimmed.len(),
        });
    }
    
    // Basic format validation - should contain at least one letter
    if !trimmed.chars().any(|c| c.is_alphabetic()) {
        result.add_error(WaqfValidationError::BeneficiaryInvalidFormat(
            "Must contain at least one letter".to_string()
        ));
    }
    
    // Check for suspicious patterns
    if trimmed.chars().all(|c| c.is_numeric()) {
        result.add_error(WaqfValidationError::BeneficiaryInvalidFormat(
            "Cannot be only numbers".to_string()
        ));
    }
}

/// Validate endowment amount
fn validate_endowment_amount(amount: f64, result: &mut WaqfValidationResult) {
    // Check for NaN and infinity
    if amount.is_nan() {
        result.add_error(WaqfValidationError::EndowmentAmountInvalid(
            "Amount cannot be NaN".to_string()
        ));
        return;
    }
    
    if amount.is_infinite() {
        result.add_error(WaqfValidationError::EndowmentAmountInvalid(
            "Amount cannot be infinite".to_string()
        ));
        return;
    }
    
    // Check range
    if amount < MIN_ENDOWMENT_AMOUNT {
        result.add_error(WaqfValidationError::EndowmentAmountTooLow {
            min_amount: MIN_ENDOWMENT_AMOUNT,
            actual: amount,
        });
    }
    
    if amount > MAX_ENDOWMENT_AMOUNT {
        result.add_error(WaqfValidationError::EndowmentAmountTooHigh {
            max_amount: MAX_ENDOWMENT_AMOUNT,
            actual: amount,
        });
    }
    
    // Check for excessive precision (more than 2 decimal places)
    let rounded = (amount * 100.0).round() / 100.0;
    if (amount - rounded).abs() > f64::EPSILON {
        result.add_warning("Endowment amount has more than 2 decimal places - will be rounded".to_string());
    }
}

/// Validate status field
fn validate_status(status: &str, result: &mut WaqfValidationResult) {
    if !VALID_STATUSES.contains(&status) {
        result.add_error(WaqfValidationError::InvalidStatus {
            status: status.to_string(),
            valid_statuses: VALID_STATUSES.iter().map(|s| s.to_string()).collect(),
        });
    }
}

/// Validate status transitions
fn validate_status_transition(from: &str, to: &str, result: &mut WaqfValidationResult) {
    if from == to {
        return; // No transition needed
    }
    
    let allowed_transitions = VALID_TRANSITIONS
        .iter()
        .find(|(status, _)| *status == from)
        .map(|(_, transitions)| *transitions)
        .unwrap_or(&[]);
    
    if !allowed_transitions.contains(&to) {
        result.add_error(WaqfValidationError::InvalidStatusTransition {
            from: from.to_string(),
            to: to.to_string(),
        });
    }
}

/// Validate timestamps
fn validate_timestamps(created_at: u64, updated_at: u64, result: &mut WaqfValidationResult) {
    // Get current timestamp (nanoseconds since epoch)
    let current_time = ic_cdk::api::time();
    
    // Convert to seconds for easier comparison
    let current_seconds = current_time / 1_000_000_000;
    let created_seconds = created_at / 1_000_000_000;
    let updated_seconds = updated_at / 1_000_000_000;
    
    // Check if timestamps are too far in the future (allow 1 hour buffer)
    let future_buffer = 3600; // 1 hour in seconds
    
    if created_seconds > current_seconds + future_buffer {
        result.add_error(WaqfValidationError::TimestampInFuture {
            timestamp: created_at,
            current: current_time,
        });
    }
    
    if updated_seconds > current_seconds + future_buffer {
        result.add_error(WaqfValidationError::TimestampInFuture {
            timestamp: updated_at,
            current: current_time,
        });
    }
    
    // Check if updated_at is before created_at
    if updated_at < created_at {
        result.add_error(WaqfValidationError::UpdatedBeforeCreated {
            created_at,
            updated_at,
        });
    }
}

/// Validate creator field
fn validate_creator(created_by: &str, result: &mut WaqfValidationResult) {
    if created_by.trim().is_empty() {
        result.add_error(WaqfValidationError::CreatedByEmpty);
        return;
    }
    
    // Basic format validation - should look like a principal ID or email
    let trimmed = created_by.trim();
    if trimmed.len() < 5 {
        result.add_error(WaqfValidationError::CreatedByInvalidFormat(
            "Creator ID too short".to_string()
        ));
    }
    
    // Check for valid characters (alphanumeric, hyphens, dots for principal IDs)
    let invalid_chars: Vec<char> = trimmed.chars()
        .filter(|&c| !c.is_alphanumeric() && c != '-' && c != '.' && c != '@')
        .collect();
    
    if !invalid_chars.is_empty() {
        let invalid_str: String = invalid_chars.into_iter().collect();
        result.add_error(WaqfValidationError::CreatedByInvalidFormat(
            format!("Contains invalid characters: {}", invalid_str)
        ));
    }
}

/// Validate business rules
fn validate_business_rules(
    data: &WaqfData, 
    current_data: Option<&WaqfData>, 
    result: &mut WaqfValidationResult
) {
    // If updating a completed waqf, block modification
    if let Some(current) = current_data {
        if current.status == "completed" && data.status != "completed" {
            result.add_error(WaqfValidationError::CompletedWaqfModification);
        }
        
        // Prevent modifying key fields of active waqfs
        if current.status == "active" {
            if current.beneficiary != data.beneficiary {
                result.add_warning("Changing beneficiary of active waqf requires additional approval".to_string());
            }
            
            if (current.endowment_amount - data.endowment_amount).abs() > f64::EPSILON {
                result.add_warning("Changing endowment amount of active waqf requires financial audit".to_string());
            }
        }
    }
    
    // Validate endowment amount against status
    if data.status == "active" && data.endowment_amount < 1.0 {
        result.add_warning("Active waqf with very low endowment amount".to_string());
    }
}

/// Validate update permissions based on current state
fn validate_update_permissions(
    current_data: &WaqfData,
    new_data: &WaqfData,
    result: &mut WaqfValidationResult,
) {
    // Check if trying to modify immutable fields of completed/cancelled waqfs
    if matches!(current_data.status.as_str(), "completed" | "cancelled") {
        if current_data.title != new_data.title ||
           current_data.description != new_data.description ||
           current_data.beneficiary != new_data.beneficiary ||
           (current_data.endowment_amount - new_data.endowment_amount).abs() > f64::EPSILON {
            result.add_error(WaqfValidationError::CompletedWaqfModification);
        }
    }
}

/// Check if character is valid for text fields
fn is_valid_text_character(c: char) -> bool {
    c.is_alphanumeric() || 
    c.is_whitespace() || 
    ".,!?;:()[]{}\"'-_/\\@#$%&*+=<>|~`^°§".contains(c)
}

/// Utility function to check if waqf can be modified
pub fn can_modify_waqf(current_status: &str) -> bool {
    !matches!(current_status, "completed" | "cancelled")
}

/// Utility function to get allowed status transitions
pub fn get_allowed_status_transitions(current_status: &str) -> Vec<String> {
    VALID_TRANSITIONS
        .iter()
        .find(|(status, _)| *status == current_status)
        .map(|(_, transitions)| transitions.iter().map(|s| s.to_string()).collect())
        .unwrap_or_else(Vec::new)
}

/// Utility function to validate status transition
pub fn is_valid_status_transition(from: &str, to: &str) -> bool {
    if from == to {
        return true; // No transition needed
    }
    
    let allowed_transitions = get_allowed_status_transitions(from);
    allowed_transitions.contains(&to.to_string())
}

/// Sanitize and normalize waqf data
pub fn sanitize_waqf_data(data: &mut WaqfData) {
    // Trim and normalize text fields
    data.title = normalize_text(&data.title);
    data.description = normalize_text(&data.description);
    data.beneficiary = normalize_text(&data.beneficiary);
    data.created_by = data.created_by.trim().to_string();
    
    // Normalize status to lowercase
    data.status = data.status.trim().to_lowercase();
    
    // Round endowment amount to 2 decimal places
    data.endowment_amount = (data.endowment_amount * 100.0).round() / 100.0;
}

/// Normalize text by trimming whitespace and collapsing multiple spaces
fn normalize_text(text: &str) -> String {
    text.trim()
        .split_whitespace()
        .collect::<Vec<&str>>()
        .join(" ")
}

/// Get validation summary for logging/monitoring
pub fn get_validation_summary(result: &WaqfValidationResult) -> String {
    if result.is_valid {
        format!("Validation passed with {} warnings", result.warnings.len())
    } else {
        format!(
            "Validation failed: {} errors, {} warnings",
            result.errors.len(),
            result.warnings.len()
        )
    }
}
